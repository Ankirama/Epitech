.TH "lib/gdl/includes/SDL_render.h" 3 "Sun Jun 7 2015" "Version 0.42" "cpp_bomberman" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/gdl/includes/SDL_render.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'SDL_stdinc\&.h'\fP
.br
\fC#include 'SDL_rect\&.h'\fP
.br
\fC#include 'SDL_video\&.h'\fP
.br
\fC#include 'begin_code\&.h'\fP
.br
\fC#include 'close_code\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBSDL_RendererInfo\fP"
.br
.RI "\fIInformation on the capabilities of a render driver or context\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBSDL_RendererInfo\fP \fBSDL_RendererInfo\fP"
.br
.RI "\fIInformation on the capabilities of a render driver or context\&. \fP"
.ti -1c
.RI "typedef struct SDL_Renderer \fBSDL_Renderer\fP"
.br
.ti -1c
.RI "typedef struct SDL_Texture \fBSDL_Texture\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBSDL_RendererFlags\fP { \fBSDL_RENDERER_SOFTWARE\fP = 0x00000001, \fBSDL_RENDERER_ACCELERATED\fP = 0x00000002, \fBSDL_RENDERER_PRESENTVSYNC\fP = 0x00000004, \fBSDL_RENDERER_TARGETTEXTURE\fP = 0x00000008 }"
.br
.RI "\fIFlags used when creating a rendering context\&. \fP"
.ti -1c
.RI "enum \fBSDL_TextureAccess\fP { \fBSDL_TEXTUREACCESS_STATIC\fP, \fBSDL_TEXTUREACCESS_STREAMING\fP, \fBSDL_TEXTUREACCESS_TARGET\fP }"
.br
.RI "\fIThe access pattern allowed for a texture\&. \fP"
.ti -1c
.RI "enum \fBSDL_TextureModulate\fP { \fBSDL_TEXTUREMODULATE_NONE\fP = 0x00000000, \fBSDL_TEXTUREMODULATE_COLOR\fP = 0x00000001, \fBSDL_TEXTUREMODULATE_ALPHA\fP = 0x00000002 }"
.br
.RI "\fIThe texture channel modulation used in \fBSDL_RenderCopy()\fP\&. \fP"
.ti -1c
.RI "enum \fBSDL_RendererFlip\fP { \fBSDL_FLIP_NONE\fP = 0x00000000, \fBSDL_FLIP_HORIZONTAL\fP = 0x00000001, \fBSDL_FLIP_VERTICAL\fP = 0x00000002 }"
.br
.RI "\fIFlip constants for SDL_RenderCopyEx\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_GetNumRenderDrivers\fP (\fBvoid\fP)"
.br
.RI "\fIGet the number of 2D rendering drivers available for the current display\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_GetRenderDriverInfo\fP (\fBint\fP index, \fBSDL_RendererInfo\fP *info)"
.br
.RI "\fIGet information about a specific 2D rendering driver for the current display\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_CreateWindowAndRenderer\fP (\fBint\fP width, \fBint\fP height, \fBUint32\fP window_flags, \fBSDL_Window\fP **window, SDL_Renderer **renderer)"
.br
.RI "\fICreate a window and default renderer\&. \fP"
.ti -1c
.RI "DECLSPEC SDL_Renderer *SDLCALL \fBSDL_CreateRenderer\fP (\fBSDL_Window\fP *window, \fBint\fP index, \fBUint32\fP flags)"
.br
.RI "\fICreate a 2D rendering context for a window\&. \fP"
.ti -1c
.RI "DECLSPEC SDL_Renderer *SDLCALL \fBSDL_CreateSoftwareRenderer\fP (\fBSDL_Surface\fP *surface)"
.br
.RI "\fICreate a 2D software rendering context for a surface\&. \fP"
.ti -1c
.RI "DECLSPEC SDL_Renderer *SDLCALL \fBSDL_GetRenderer\fP (\fBSDL_Window\fP *window)"
.br
.RI "\fIGet the renderer associated with a window\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_GetRendererInfo\fP (SDL_Renderer *renderer, \fBSDL_RendererInfo\fP *info)"
.br
.RI "\fIGet information about a rendering context\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_GetRendererOutputSize\fP (SDL_Renderer *renderer, \fBint\fP *w, \fBint\fP *h)"
.br
.RI "\fIGet the output size of a rendering context\&. \fP"
.ti -1c
.RI "DECLSPEC SDL_Texture *SDLCALL \fBSDL_CreateTexture\fP (SDL_Renderer *renderer, \fBUint32\fP format, \fBint\fP access, \fBint\fP w, \fBint\fP h)"
.br
.RI "\fICreate a texture for a rendering context\&. \fP"
.ti -1c
.RI "DECLSPEC SDL_Texture *SDLCALL \fBSDL_CreateTextureFromSurface\fP (SDL_Renderer *renderer, \fBSDL_Surface\fP *surface)"
.br
.RI "\fICreate a texture from an existing surface\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_QueryTexture\fP (SDL_Texture *texture, \fBUint32\fP *format, \fBint\fP *access, \fBint\fP *w, \fBint\fP *h)"
.br
.RI "\fIQuery the attributes of a texture\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_SetTextureColorMod\fP (SDL_Texture *texture, \fBUint8\fP r, \fBUint8\fP g, \fBUint8\fP b)"
.br
.RI "\fISet an additional color value used in render copy operations\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_GetTextureColorMod\fP (SDL_Texture *texture, \fBUint8\fP *r, \fBUint8\fP *g, \fBUint8\fP *b)"
.br
.RI "\fIGet the additional color value used in render copy operations\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_SetTextureAlphaMod\fP (SDL_Texture *texture, \fBUint8\fP alpha)"
.br
.RI "\fISet an additional alpha value used in render copy operations\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_GetTextureAlphaMod\fP (SDL_Texture *texture, \fBUint8\fP *alpha)"
.br
.RI "\fIGet the additional alpha value used in render copy operations\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_SetTextureBlendMode\fP (SDL_Texture *texture, \fBSDL_BlendMode\fP blendMode)"
.br
.RI "\fISet the blend mode used for texture copy operations\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_GetTextureBlendMode\fP (SDL_Texture *texture, \fBSDL_BlendMode\fP *blendMode)"
.br
.RI "\fIGet the blend mode used for texture copy operations\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_UpdateTexture\fP (SDL_Texture *texture, const \fBSDL_Rect\fP *rect, const \fBvoid\fP *pixels, \fBint\fP pitch)"
.br
.RI "\fIUpdate the given texture rectangle with new pixel data\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_UpdateYUVTexture\fP (SDL_Texture *texture, const \fBSDL_Rect\fP *rect, const \fBUint8\fP *Yplane, \fBint\fP Ypitch, const \fBUint8\fP *Uplane, \fBint\fP Upitch, const \fBUint8\fP *Vplane, \fBint\fP Vpitch)"
.br
.RI "\fIUpdate a rectangle within a planar YV12 or IYUV texture with new pixel data\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_LockTexture\fP (SDL_Texture *texture, const \fBSDL_Rect\fP *rect, \fBvoid\fP **pixels, \fBint\fP *pitch)"
.br
.RI "\fILock a portion of the texture for write-only pixel access\&. \fP"
.ti -1c
.RI "DECLSPEC \fBvoid\fP SDLCALL \fBSDL_UnlockTexture\fP (SDL_Texture *texture)"
.br
.RI "\fIUnlock a texture, uploading the changes to video memory, if needed\&. \fP"
.ti -1c
.RI "DECLSPEC SDL_bool SDLCALL \fBSDL_RenderTargetSupported\fP (SDL_Renderer *renderer)"
.br
.RI "\fIDetermines whether a window supports the use of render targets\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_SetRenderTarget\fP (SDL_Renderer *renderer, SDL_Texture *texture)"
.br
.RI "\fISet a texture as the current rendering target\&. \fP"
.ti -1c
.RI "DECLSPEC SDL_Texture *SDLCALL \fBSDL_GetRenderTarget\fP (SDL_Renderer *renderer)"
.br
.RI "\fIGet the current render target or NULL for the default render target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderSetLogicalSize\fP (SDL_Renderer *renderer, \fBint\fP w, \fBint\fP h)"
.br
.RI "\fISet device independent resolution for rendering\&. \fP"
.ti -1c
.RI "DECLSPEC \fBvoid\fP SDLCALL \fBSDL_RenderGetLogicalSize\fP (SDL_Renderer *renderer, \fBint\fP *w, \fBint\fP *h)"
.br
.RI "\fIGet device independent resolution for rendering\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderSetViewport\fP (SDL_Renderer *renderer, const \fBSDL_Rect\fP *rect)"
.br
.RI "\fISet the drawing area for rendering on the current target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBvoid\fP SDLCALL \fBSDL_RenderGetViewport\fP (SDL_Renderer *renderer, \fBSDL_Rect\fP *rect)"
.br
.RI "\fIGet the drawing area for the current target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderSetClipRect\fP (SDL_Renderer *renderer, const \fBSDL_Rect\fP *rect)"
.br
.RI "\fISet the clip rectangle for the current target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBvoid\fP SDLCALL \fBSDL_RenderGetClipRect\fP (SDL_Renderer *renderer, \fBSDL_Rect\fP *rect)"
.br
.RI "\fIGet the clip rectangle for the current target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderSetScale\fP (SDL_Renderer *renderer, float scaleX, float scaleY)"
.br
.RI "\fISet the drawing scale for rendering on the current target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBvoid\fP SDLCALL \fBSDL_RenderGetScale\fP (SDL_Renderer *renderer, float *scaleX, float *scaleY)"
.br
.RI "\fIGet the drawing scale for the current target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_SetRenderDrawColor\fP (SDL_Renderer *renderer, \fBUint8\fP r, \fBUint8\fP g, \fBUint8\fP b, \fBUint8\fP a)"
.br
.RI "\fISet the color used for drawing operations (Rect, Line and Clear)\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_GetRenderDrawColor\fP (SDL_Renderer *renderer, \fBUint8\fP *r, \fBUint8\fP *g, \fBUint8\fP *b, \fBUint8\fP *a)"
.br
.RI "\fIGet the color used for drawing operations (Rect, Line and Clear)\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_SetRenderDrawBlendMode\fP (SDL_Renderer *renderer, \fBSDL_BlendMode\fP blendMode)"
.br
.RI "\fISet the blend mode used for drawing operations (Fill and Line)\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_GetRenderDrawBlendMode\fP (SDL_Renderer *renderer, \fBSDL_BlendMode\fP *blendMode)"
.br
.RI "\fIGet the blend mode used for drawing operations\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderClear\fP (SDL_Renderer *renderer)"
.br
.RI "\fIClear the current rendering target with the drawing color\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderDrawPoint\fP (SDL_Renderer *renderer, \fBint\fP x, \fBint\fP y)"
.br
.RI "\fIDraw a point on the current rendering target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderDrawPoints\fP (SDL_Renderer *renderer, const \fBSDL_Point\fP *points, \fBint\fP count)"
.br
.RI "\fIDraw multiple points on the current rendering target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderDrawLine\fP (SDL_Renderer *renderer, \fBint\fP x1, \fBint\fP y1, \fBint\fP x2, \fBint\fP y2)"
.br
.RI "\fIDraw a line on the current rendering target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderDrawLines\fP (SDL_Renderer *renderer, const \fBSDL_Point\fP *points, \fBint\fP count)"
.br
.RI "\fIDraw a series of connected lines on the current rendering target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderDrawRect\fP (SDL_Renderer *renderer, const \fBSDL_Rect\fP *rect)"
.br
.RI "\fIDraw a rectangle on the current rendering target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderDrawRects\fP (SDL_Renderer *renderer, const \fBSDL_Rect\fP *rects, \fBint\fP count)"
.br
.RI "\fIDraw some number of rectangles on the current rendering target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderFillRect\fP (SDL_Renderer *renderer, const \fBSDL_Rect\fP *rect)"
.br
.RI "\fIFill a rectangle on the current rendering target with the drawing color\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderFillRects\fP (SDL_Renderer *renderer, const \fBSDL_Rect\fP *rects, \fBint\fP count)"
.br
.RI "\fIFill some number of rectangles on the current rendering target with the drawing color\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderCopy\fP (SDL_Renderer *renderer, SDL_Texture *texture, const \fBSDL_Rect\fP *srcrect, const \fBSDL_Rect\fP *dstrect)"
.br
.RI "\fICopy a portion of the texture to the current rendering target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderCopyEx\fP (SDL_Renderer *renderer, SDL_Texture *texture, const \fBSDL_Rect\fP *srcrect, const \fBSDL_Rect\fP *dstrect, const double angle, const \fBSDL_Point\fP *center, const \fBSDL_RendererFlip\fP flip)"
.br
.RI "\fICopy a portion of the source texture to the current rendering target, rotating it by angle around the given center\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_RenderReadPixels\fP (SDL_Renderer *renderer, const \fBSDL_Rect\fP *rect, \fBUint32\fP format, \fBvoid\fP *pixels, \fBint\fP pitch)"
.br
.RI "\fIRead pixels from the current rendering target\&. \fP"
.ti -1c
.RI "DECLSPEC \fBvoid\fP SDLCALL \fBSDL_RenderPresent\fP (SDL_Renderer *renderer)"
.br
.RI "\fIUpdate the screen with rendering performed\&. \fP"
.ti -1c
.RI "DECLSPEC \fBvoid\fP SDLCALL \fBSDL_DestroyTexture\fP (SDL_Texture *texture)"
.br
.RI "\fIDestroy the specified texture\&. \fP"
.ti -1c
.RI "DECLSPEC \fBvoid\fP SDLCALL \fBSDL_DestroyRenderer\fP (SDL_Renderer *renderer)"
.br
.RI "\fIDestroy the rendering context for a window and free associated textures\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_GL_BindTexture\fP (SDL_Texture *texture, float *texw, float *texh)"
.br
.RI "\fIBind the texture to the current OpenGL/ES/ES2 context for use with OpenGL instructions\&. \fP"
.ti -1c
.RI "DECLSPEC \fBint\fP SDLCALL \fBSDL_GL_UnbindTexture\fP (SDL_Texture *texture)"
.br
.RI "\fIUnbind a texture from the current OpenGL/ES/ES2 context\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Header file for SDL 2D rendering functions\&.
.PP
This API supports the following features:
.IP "\(bu" 2
single pixel points
.IP "\(bu" 2
single pixel lines
.IP "\(bu" 2
filled rectangles
.IP "\(bu" 2
texture images
.PP
.PP
The primitives may be drawn in opaque, blended, or additive modes\&.
.PP
The texture images may be drawn in opaque, blended, or additive modes\&. They can have an additional color tint or alpha modulation applied to them, and may also be stretched with linear interpolation\&.
.PP
This API is designed to accelerate simple 2D operations\&. You may want more functionality such as polygons and particle effects and in that case you should use SDL's OpenGL/Direct3D support or one of the many good 3D engines\&.
.PP
These functions must be called from the main thread\&. See this bug for details: http://bugzilla.libsdl.org/show_bug.cgi?id=1995 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBSDL_RendererFlags\fP"

.PP
Flags used when creating a rendering context\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISDL_RENDERER_SOFTWARE \fP\fP
The renderer is a software fallback 
.TP
\fB\fISDL_RENDERER_ACCELERATED \fP\fP
The renderer uses hardware acceleration 
.TP
\fB\fISDL_RENDERER_PRESENTVSYNC \fP\fP
Present is synchronized with the refresh rate 
.TP
\fB\fISDL_RENDERER_TARGETTEXTURE \fP\fP
The renderer supports rendering to texture 
.SS "enum \fBSDL_RendererFlip\fP"

.PP
Flip constants for SDL_RenderCopyEx\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISDL_FLIP_NONE \fP\fP
Do not flip 
.TP
\fB\fISDL_FLIP_HORIZONTAL \fP\fP
flip horizontally 
.TP
\fB\fISDL_FLIP_VERTICAL \fP\fP
flip vertically 
.SS "enum \fBSDL_TextureAccess\fP"

.PP
The access pattern allowed for a texture\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISDL_TEXTUREACCESS_STATIC \fP\fP
Changes rarely, not lockable 
.TP
\fB\fISDL_TEXTUREACCESS_STREAMING \fP\fP
Changes frequently, lockable 
.TP
\fB\fISDL_TEXTUREACCESS_TARGET \fP\fP
Texture can be used as a render target 
.SS "enum \fBSDL_TextureModulate\fP"

.PP
The texture channel modulation used in \fBSDL_RenderCopy()\fP\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISDL_TEXTUREMODULATE_NONE \fP\fP
No modulation 
.TP
\fB\fISDL_TEXTUREMODULATE_COLOR \fP\fP
srcC = srcC * color 
.TP
\fB\fISDL_TEXTUREMODULATE_ALPHA \fP\fP
srcA = srcA * alpha 
.SH "Function Documentation"
.PP 
.SS "DECLSPEC SDL_Renderer* SDLCALL SDL_CreateRenderer (\fBSDL_Window\fP * window, \fBint\fP index, \fBUint32\fP flags)"

.PP
Create a 2D rendering context for a window\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwindow\fP The window where rendering is displayed\&. 
.br
\fIindex\fP The index of the rendering driver to initialize, or -1 to initialize the first one supporting the requested flags\&. 
.br
\fIflags\fP \fBSDL_RendererFlags\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A valid rendering context or NULL if there was an error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_CreateSoftwareRenderer()\fP 
.PP
\fBSDL_GetRendererInfo()\fP 
.PP
\fBSDL_DestroyRenderer()\fP 
.RE
.PP

.SS "DECLSPEC SDL_Renderer* SDLCALL SDL_CreateSoftwareRenderer (\fBSDL_Surface\fP * surface)"

.PP
Create a 2D software rendering context for a surface\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsurface\fP The surface where rendering is done\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A valid rendering context or NULL if there was an error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_CreateRenderer()\fP 
.PP
\fBSDL_DestroyRenderer()\fP 
.RE
.PP

.SS "DECLSPEC SDL_Texture* SDLCALL SDL_CreateTexture (SDL_Renderer * renderer, \fBUint32\fP format, \fBint\fP access, \fBint\fP w, \fBint\fP h)"

.PP
Create a texture for a rendering context\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer\&. 
.br
\fIformat\fP The format of the texture\&. 
.br
\fIaccess\fP One of the enumerated values in \fBSDL_TextureAccess\fP\&. 
.br
\fIw\fP The width of the texture in pixels\&. 
.br
\fIh\fP The height of the texture in pixels\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The created texture is returned, or 0 if no rendering context was active, the format was unsupported, or the width or height were out of range\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_QueryTexture()\fP 
.PP
\fBSDL_UpdateTexture()\fP 
.PP
\fBSDL_DestroyTexture()\fP 
.RE
.PP

.SS "DECLSPEC SDL_Texture* SDLCALL SDL_CreateTextureFromSurface (SDL_Renderer * renderer, \fBSDL_Surface\fP * surface)"

.PP
Create a texture from an existing surface\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer\&. 
.br
\fIsurface\fP The surface containing pixel data used to fill the texture\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The created texture is returned, or 0 on error\&.
.RE
.PP
\fBNote:\fP
.RS 4
The surface is not modified or freed by this function\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_QueryTexture()\fP 
.PP
\fBSDL_DestroyTexture()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_CreateWindowAndRenderer (\fBint\fP width, \fBint\fP height, \fBUint32\fP window_flags, \fBSDL_Window\fP ** window, SDL_Renderer ** renderer)"

.PP
Create a window and default renderer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwidth\fP The width of the window 
.br
\fIheight\fP The height of the window 
.br
\fIwindow_flags\fP The flags used to create the window 
.br
\fIwindow\fP A pointer filled with the window, or NULL on error 
.br
\fIrenderer\fP A pointer filled with the renderer, or NULL on error
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBvoid\fP SDLCALL SDL_DestroyRenderer (SDL_Renderer * renderer)"

.PP
Destroy the rendering context for a window and free associated textures\&. 
.PP
\fBSee also:\fP
.RS 4
\fBSDL_CreateRenderer()\fP 
.RE
.PP

.SS "DECLSPEC \fBvoid\fP SDLCALL SDL_DestroyTexture (SDL_Texture * texture)"

.PP
Destroy the specified texture\&. 
.PP
\fBSee also:\fP
.RS 4
\fBSDL_CreateTexture()\fP 
.PP
\fBSDL_CreateTextureFromSurface()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_GetNumRenderDrivers (\fBvoid\fP)"

.PP
Get the number of 2D rendering drivers available for the current display\&. A render driver is a set of code that handles rendering and texture management on a particular display\&. Normally there is only one, but some drivers may have several available with different capabilities\&.
.PP
\fBSee also:\fP
.RS 4
\fBSDL_GetRenderDriverInfo()\fP 
.PP
\fBSDL_CreateRenderer()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_GetRenderDrawBlendMode (SDL_Renderer * renderer, \fBSDL_BlendMode\fP * blendMode)"

.PP
Get the blend mode used for drawing operations\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer from which blend mode should be queried\&. 
.br
\fIblendMode\fP A pointer filled in with the current blend mode\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_SetRenderDrawBlendMode()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_GetRenderDrawColor (SDL_Renderer * renderer, \fBUint8\fP * r, \fBUint8\fP * g, \fBUint8\fP * b, \fBUint8\fP * a)"

.PP
Get the color used for drawing operations (Rect, Line and Clear)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer from which drawing color should be queried\&. 
.br
\fIr\fP A pointer to the red value used to draw on the rendering target\&. 
.br
\fIg\fP A pointer to the green value used to draw on the rendering target\&. 
.br
\fIb\fP A pointer to the blue value used to draw on the rendering target\&. 
.br
\fIa\fP A pointer to the alpha value used to draw on the rendering target, usually ::SDL_ALPHA_OPAQUE (255)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_GetRenderDriverInfo (\fBint\fP index, \fBSDL_RendererInfo\fP * info)"

.PP
Get information about a specific 2D rendering driver for the current display\&. 
.PP
\fBParameters:\fP
.RS 4
\fIindex\fP The index of the driver to query information about\&. 
.br
\fIinfo\fP A pointer to an \fBSDL_RendererInfo\fP struct to be filled with information on the rendering driver\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 if the index was out of range\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_CreateRenderer()\fP 
.RE
.PP

.SS "DECLSPEC SDL_Texture* SDLCALL SDL_GetRenderTarget (SDL_Renderer * renderer)"

.PP
Get the current render target or NULL for the default render target\&. 
.PP
\fBReturns:\fP
.RS 4
The current render target
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_SetRenderTarget()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_GetTextureAlphaMod (SDL_Texture * texture, \fBUint8\fP * alpha)"

.PP
Get the additional alpha value used in render copy operations\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP The texture to query\&. 
.br
\fIalpha\fP A pointer filled in with the current alpha value\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the texture is not valid\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_SetTextureAlphaMod()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_GetTextureBlendMode (SDL_Texture * texture, \fBSDL_BlendMode\fP * blendMode)"

.PP
Get the blend mode used for texture copy operations\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP The texture to query\&. 
.br
\fIblendMode\fP A pointer filled in with the current blend mode\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the texture is not valid\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_SetTextureBlendMode()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_GetTextureColorMod (SDL_Texture * texture, \fBUint8\fP * r, \fBUint8\fP * g, \fBUint8\fP * b)"

.PP
Get the additional color value used in render copy operations\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP The texture to query\&. 
.br
\fIr\fP A pointer filled in with the current red color value\&. 
.br
\fIg\fP A pointer filled in with the current green color value\&. 
.br
\fIb\fP A pointer filled in with the current blue color value\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the texture is not valid\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_SetTextureColorMod()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_GL_BindTexture (SDL_Texture * texture, float * texw, float * texh)"

.PP
Bind the texture to the current OpenGL/ES/ES2 context for use with OpenGL instructions\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP The SDL texture to bind 
.br
\fItexw\fP A pointer to a float that will be filled with the texture width 
.br
\fItexh\fP A pointer to a float that will be filled with the texture height
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the operation is not supported 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_GL_UnbindTexture (SDL_Texture * texture)"

.PP
Unbind a texture from the current OpenGL/ES/ES2 context\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP The SDL texture to unbind
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the operation is not supported 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_LockTexture (SDL_Texture * texture, const \fBSDL_Rect\fP * rect, \fBvoid\fP ** pixels, \fBint\fP * pitch)"

.PP
Lock a portion of the texture for write-only pixel access\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP The texture to lock for access, which was created with \fBSDL_TEXTUREACCESS_STREAMING\fP\&. 
.br
\fIrect\fP A pointer to the rectangle to lock for access\&. If the rect is NULL, the entire texture will be locked\&. 
.br
\fIpixels\fP This is filled in with a pointer to the locked pixels, appropriately offset by the locked area\&. 
.br
\fIpitch\fP This is filled in with the pitch of the locked pixels\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the texture is not valid or was not created with \fBSDL_TEXTUREACCESS_STREAMING\fP\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_UnlockTexture()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_QueryTexture (SDL_Texture * texture, \fBUint32\fP * format, \fBint\fP * access, \fBint\fP * w, \fBint\fP * h)"

.PP
Query the attributes of a texture\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP A texture to be queried\&. 
.br
\fIformat\fP A pointer filled in with the raw format of the texture\&. The actual format may differ, but pixel transfers will use this format\&. 
.br
\fIaccess\fP A pointer filled in with the actual access to the texture\&. 
.br
\fIw\fP A pointer filled in with the width of the texture in pixels\&. 
.br
\fIh\fP A pointer filled in with the height of the texture in pixels\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the texture is not valid\&. 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderClear (SDL_Renderer * renderer)"

.PP
Clear the current rendering target with the drawing color\&. This function clears the entire rendering target, ignoring the viewport\&.
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderCopy (SDL_Renderer * renderer, SDL_Texture * texture, const \fBSDL_Rect\fP * srcrect, const \fBSDL_Rect\fP * dstrect)"

.PP
Copy a portion of the texture to the current rendering target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer which should copy parts of a texture\&. 
.br
\fItexture\fP The source texture\&. 
.br
\fIsrcrect\fP A pointer to the source rectangle, or NULL for the entire texture\&. 
.br
\fIdstrect\fP A pointer to the destination rectangle, or NULL for the entire rendering target\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderCopyEx (SDL_Renderer * renderer, SDL_Texture * texture, const \fBSDL_Rect\fP * srcrect, const \fBSDL_Rect\fP * dstrect, const double angle, const \fBSDL_Point\fP * center, const \fBSDL_RendererFlip\fP flip)"

.PP
Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer which should copy parts of a texture\&. 
.br
\fItexture\fP The source texture\&. 
.br
\fIsrcrect\fP A pointer to the source rectangle, or NULL for the entire texture\&. 
.br
\fIdstrect\fP A pointer to the destination rectangle, or NULL for the entire rendering target\&. 
.br
\fIangle\fP An angle in degrees that indicates the rotation that will be applied to dstrect 
.br
\fIcenter\fP A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done aroud dstrect\&.w/2, dstrect\&.h/2) 
.br
\fIflip\fP An SDL_RendererFlip value stating which flipping actions should be performed on the texture
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderDrawLine (SDL_Renderer * renderer, \fBint\fP x1, \fBint\fP y1, \fBint\fP x2, \fBint\fP y2)"

.PP
Draw a line on the current rendering target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer which should draw a line\&. 
.br
\fIx1\fP The x coordinate of the start point\&. 
.br
\fIy1\fP The y coordinate of the start point\&. 
.br
\fIx2\fP The x coordinate of the end point\&. 
.br
\fIy2\fP The y coordinate of the end point\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderDrawLines (SDL_Renderer * renderer, const \fBSDL_Point\fP * points, \fBint\fP count)"

.PP
Draw a series of connected lines on the current rendering target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer which should draw multiple lines\&. 
.br
\fIpoints\fP The points along the lines 
.br
\fIcount\fP The number of points, drawing count-1 lines
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderDrawPoint (SDL_Renderer * renderer, \fBint\fP x, \fBint\fP y)"

.PP
Draw a point on the current rendering target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer which should draw a point\&. 
.br
\fIx\fP The x coordinate of the point\&. 
.br
\fIy\fP The y coordinate of the point\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderDrawPoints (SDL_Renderer * renderer, const \fBSDL_Point\fP * points, \fBint\fP count)"

.PP
Draw multiple points on the current rendering target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer which should draw multiple points\&. 
.br
\fIpoints\fP The points to draw 
.br
\fIcount\fP The number of points to draw
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderDrawRect (SDL_Renderer * renderer, const \fBSDL_Rect\fP * rect)"

.PP
Draw a rectangle on the current rendering target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer which should draw a rectangle\&. 
.br
\fIrect\fP A pointer to the destination rectangle, or NULL to outline the entire rendering target\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderDrawRects (SDL_Renderer * renderer, const \fBSDL_Rect\fP * rects, \fBint\fP count)"

.PP
Draw some number of rectangles on the current rendering target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer which should draw multiple rectangles\&. 
.br
\fIrects\fP A pointer to an array of destination rectangles\&. 
.br
\fIcount\fP The number of rectangles\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderFillRect (SDL_Renderer * renderer, const \fBSDL_Rect\fP * rect)"

.PP
Fill a rectangle on the current rendering target with the drawing color\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer which should fill a rectangle\&. 
.br
\fIrect\fP A pointer to the destination rectangle, or NULL for the entire rendering target\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderFillRects (SDL_Renderer * renderer, const \fBSDL_Rect\fP * rects, \fBint\fP count)"

.PP
Fill some number of rectangles on the current rendering target with the drawing color\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer which should fill multiple rectangles\&. 
.br
\fIrects\fP A pointer to an array of destination rectangles\&. 
.br
\fIcount\fP The number of rectangles\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBvoid\fP SDLCALL SDL_RenderGetClipRect (SDL_Renderer * renderer, \fBSDL_Rect\fP * rect)"

.PP
Get the clip rectangle for the current target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer from which clip rectangle should be queried\&. 
.br
\fIrect\fP A pointer filled in with the current clip rectangle, or an empty rectangle if clipping is disabled\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_RenderSetClipRect()\fP 
.RE
.PP

.SS "DECLSPEC \fBvoid\fP SDLCALL SDL_RenderGetLogicalSize (SDL_Renderer * renderer, \fBint\fP * w, \fBint\fP * h)"

.PP
Get device independent resolution for rendering\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer from which resolution should be queried\&. 
.br
\fIw\fP A pointer filled with the width of the logical resolution 
.br
\fIh\fP A pointer filled with the height of the logical resolution
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_RenderSetLogicalSize()\fP 
.RE
.PP

.SS "DECLSPEC \fBvoid\fP SDLCALL SDL_RenderGetScale (SDL_Renderer * renderer, float * scaleX, float * scaleY)"

.PP
Get the drawing scale for the current target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer from which drawing scale should be queried\&. 
.br
\fIscaleX\fP A pointer filled in with the horizontal scaling factor 
.br
\fIscaleY\fP A pointer filled in with the vertical scaling factor
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_RenderSetScale()\fP 
.RE
.PP

.SS "DECLSPEC \fBvoid\fP SDLCALL SDL_RenderGetViewport (SDL_Renderer * renderer, \fBSDL_Rect\fP * rect)"

.PP
Get the drawing area for the current target\&. 
.PP
\fBSee also:\fP
.RS 4
\fBSDL_RenderSetViewport()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderReadPixels (SDL_Renderer * renderer, const \fBSDL_Rect\fP * rect, \fBUint32\fP format, \fBvoid\fP * pixels, \fBint\fP pitch)"

.PP
Read pixels from the current rendering target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer from which pixels should be read\&. 
.br
\fIrect\fP A pointer to the rectangle to read, or NULL for the entire render target\&. 
.br
\fIformat\fP The desired format of the pixel data, or 0 to use the format of the rendering target 
.br
\fIpixels\fP A pointer to be filled in with the pixel data 
.br
\fIpitch\fP The pitch of the pixels parameter\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if pixel reading is not supported\&.
.RE
.PP
\fBWarning:\fP
.RS 4
This is a very slow operation, and should not be used frequently\&. 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderSetClipRect (SDL_Renderer * renderer, const \fBSDL_Rect\fP * rect)"

.PP
Set the clip rectangle for the current target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer for which clip rectangle should be set\&. 
.br
\fIrect\fP A pointer to the rectangle to set as the clip rectangle, or NULL to disable clipping\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_RenderGetClipRect()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderSetLogicalSize (SDL_Renderer * renderer, \fBint\fP w, \fBint\fP h)"

.PP
Set device independent resolution for rendering\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer for which resolution should be set\&. 
.br
\fIw\fP The width of the logical resolution 
.br
\fIh\fP The height of the logical resolution
.RE
.PP
This function uses the viewport and scaling functionality to allow a fixed logical resolution for rendering, regardless of the actual output resolution\&. If the actual output resolution doesn't have the same aspect ratio the output rendering will be centered within the output display\&.
.PP
If the output display is a window, mouse events in the window will be filtered and scaled so they seem to arrive within the logical resolution\&.
.PP
\fBNote:\fP
.RS 4
If this function results in scaling or subpixel drawing by the rendering backend, it will be handled using the appropriate quality hints\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_RenderGetLogicalSize()\fP 
.PP
\fBSDL_RenderSetScale()\fP 
.PP
\fBSDL_RenderSetViewport()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderSetScale (SDL_Renderer * renderer, float scaleX, float scaleY)"

.PP
Set the drawing scale for rendering on the current target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer for which the drawing scale should be set\&. 
.br
\fIscaleX\fP The horizontal scaling factor 
.br
\fIscaleY\fP The vertical scaling factor
.RE
.PP
The drawing coordinates are scaled by the x/y scaling factors before they are used by the renderer\&. This allows resolution independent drawing with a single coordinate system\&.
.PP
\fBNote:\fP
.RS 4
If this results in scaling or subpixel drawing by the rendering backend, it will be handled using the appropriate quality hints\&. For best results use integer scaling factors\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_RenderGetScale()\fP 
.PP
\fBSDL_RenderSetLogicalSize()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_RenderSetViewport (SDL_Renderer * renderer, const \fBSDL_Rect\fP * rect)"

.PP
Set the drawing area for rendering on the current target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer for which the drawing area should be set\&. 
.br
\fIrect\fP The rectangle representing the drawing area, or NULL to set the viewport to the entire target\&.
.RE
.PP
The x,y of the viewport rect represents the origin for rendering\&.
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error
.RE
.PP
\fBNote:\fP
.RS 4
If the window associated with the renderer is resized, the viewport is automatically reset\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_RenderGetViewport()\fP 
.PP
\fBSDL_RenderSetLogicalSize()\fP 
.RE
.PP

.SS "DECLSPEC SDL_bool SDLCALL SDL_RenderTargetSupported (SDL_Renderer * renderer)"

.PP
Determines whether a window supports the use of render targets\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer that will be checked
.RE
.PP
\fBReturns:\fP
.RS 4
SDL_TRUE if supported, SDL_FALSE if not\&. 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_SetRenderDrawBlendMode (SDL_Renderer * renderer, \fBSDL_BlendMode\fP blendMode)"

.PP
Set the blend mode used for drawing operations (Fill and Line)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer for which blend mode should be set\&. 
.br
\fIblendMode\fP \fBSDL_BlendMode\fP to use for blending\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error
.RE
.PP
\fBNote:\fP
.RS 4
If the blend mode is not supported, the closest supported mode is chosen\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_GetRenderDrawBlendMode()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_SetRenderDrawColor (SDL_Renderer * renderer, \fBUint8\fP r, \fBUint8\fP g, \fBUint8\fP b, \fBUint8\fP a)"

.PP
Set the color used for drawing operations (Rect, Line and Clear)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer for which drawing color should be set\&. 
.br
\fIr\fP The red value used to draw on the rendering target\&. 
.br
\fIg\fP The green value used to draw on the rendering target\&. 
.br
\fIb\fP The blue value used to draw on the rendering target\&. 
.br
\fIa\fP The alpha value used to draw on the rendering target, usually ::SDL_ALPHA_OPAQUE (255)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_SetRenderTarget (SDL_Renderer * renderer, SDL_Texture * texture)"

.PP
Set a texture as the current rendering target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrenderer\fP The renderer\&. 
.br
\fItexture\fP The targeted texture, which must be created with the SDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 on error
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_GetRenderTarget()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_SetTextureAlphaMod (SDL_Texture * texture, \fBUint8\fP alpha)"

.PP
Set an additional alpha value used in render copy operations\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP The texture to update\&. 
.br
\fIalpha\fP The alpha value multiplied into copy operations\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the texture is not valid or alpha modulation is not supported\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_GetTextureAlphaMod()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_SetTextureBlendMode (SDL_Texture * texture, \fBSDL_BlendMode\fP blendMode)"

.PP
Set the blend mode used for texture copy operations\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP The texture to update\&. 
.br
\fIblendMode\fP \fBSDL_BlendMode\fP to use for texture blending\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the texture is not valid or the blend mode is not supported\&.
.RE
.PP
\fBNote:\fP
.RS 4
If the blend mode is not supported, the closest supported mode is chosen\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_GetTextureBlendMode()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_SetTextureColorMod (SDL_Texture * texture, \fBUint8\fP r, \fBUint8\fP g, \fBUint8\fP b)"

.PP
Set an additional color value used in render copy operations\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP The texture to update\&. 
.br
\fIr\fP The red color value multiplied into copy operations\&. 
.br
\fIg\fP The green color value multiplied into copy operations\&. 
.br
\fIb\fP The blue color value multiplied into copy operations\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the texture is not valid or color modulation is not supported\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBSDL_GetTextureColorMod()\fP 
.RE
.PP

.SS "DECLSPEC \fBvoid\fP SDLCALL SDL_UnlockTexture (SDL_Texture * texture)"

.PP
Unlock a texture, uploading the changes to video memory, if needed\&. 
.PP
\fBSee also:\fP
.RS 4
\fBSDL_LockTexture()\fP 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_UpdateTexture (SDL_Texture * texture, const \fBSDL_Rect\fP * rect, const \fBvoid\fP * pixels, \fBint\fP pitch)"

.PP
Update the given texture rectangle with new pixel data\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP The texture to update 
.br
\fIrect\fP A pointer to the rectangle of pixels to update, or NULL to update the entire texture\&. 
.br
\fIpixels\fP The raw pixel data\&. 
.br
\fIpitch\fP The number of bytes between rows of pixel data\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the texture is not valid\&.
.RE
.PP
\fBNote:\fP
.RS 4
This is a fairly slow function\&. 
.RE
.PP

.SS "DECLSPEC \fBint\fP SDLCALL SDL_UpdateYUVTexture (SDL_Texture * texture, const \fBSDL_Rect\fP * rect, const \fBUint8\fP * Yplane, \fBint\fP Ypitch, const \fBUint8\fP * Uplane, \fBint\fP Upitch, const \fBUint8\fP * Vplane, \fBint\fP Vpitch)"

.PP
Update a rectangle within a planar YV12 or IYUV texture with new pixel data\&. 
.PP
\fBParameters:\fP
.RS 4
\fItexture\fP The texture to update 
.br
\fIrect\fP A pointer to the rectangle of pixels to update, or NULL to update the entire texture\&. 
.br
\fIYplane\fP The raw pixel data for the Y plane\&. 
.br
\fIYpitch\fP The number of bytes between rows of pixel data for the Y plane\&. 
.br
\fIUplane\fP The raw pixel data for the U plane\&. 
.br
\fIUpitch\fP The number of bytes between rows of pixel data for the U plane\&. 
.br
\fIVplane\fP The raw pixel data for the V plane\&. 
.br
\fIVpitch\fP The number of bytes between rows of pixel data for the V plane\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, or -1 if the texture is not valid\&.
.RE
.PP
\fBNote:\fP
.RS 4
You can use \fBSDL_UpdateTexture()\fP as long as your pixel data is a contiguous block of Y and U/V planes in the proper order, but this function is available if your pixel data is not contiguous\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for cpp_bomberman from the source code\&.
