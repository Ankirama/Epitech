.TH "tinyxml2::XMLNode" 3 "Tue Jun 9 2015" "Version 0.53" "cpp_bomberman" \" -*- nroff -*-
.ad l
.nh
.SH NAME
tinyxml2::XMLNode \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <tinyxml2\&.h>\fP
.PP
Inherited by \fBtinyxml2::XMLComment\fP, \fBtinyxml2::XMLDeclaration\fP, \fBtinyxml2::XMLDocument\fP, \fBtinyxml2::XMLElement\fP, \fBtinyxml2::XMLText\fP, and \fBtinyxml2::XMLUnknown\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "const \fBXMLDocument\fP * \fBGetDocument\fP () const "
.br
.RI "\fIGet the \fBXMLDocument\fP that owns this \fBXMLNode\fP\&. \fP"
.ti -1c
.RI "\fBXMLDocument\fP * \fBGetDocument\fP ()"
.br
.RI "\fIGet the \fBXMLDocument\fP that owns this \fBXMLNode\fP\&. \fP"
.ti -1c
.RI "virtual \fBXMLElement\fP * \fBToElement\fP ()"
.br
.RI "\fISafely cast to an Element, or null\&. \fP"
.ti -1c
.RI "virtual \fBXMLText\fP * \fBToText\fP ()"
.br
.RI "\fISafely cast to Text, or null\&. \fP"
.ti -1c
.RI "virtual \fBXMLComment\fP * \fBToComment\fP ()"
.br
.RI "\fISafely cast to a Comment, or null\&. \fP"
.ti -1c
.RI "virtual \fBXMLDocument\fP * \fBToDocument\fP ()"
.br
.RI "\fISafely cast to a Document, or null\&. \fP"
.ti -1c
.RI "virtual \fBXMLDeclaration\fP * \fBToDeclaration\fP ()"
.br
.RI "\fISafely cast to a Declaration, or null\&. \fP"
.ti -1c
.RI "virtual \fBXMLUnknown\fP * \fBToUnknown\fP ()"
.br
.RI "\fISafely cast to an Unknown, or null\&. \fP"
.ti -1c
.RI "virtual const \fBXMLElement\fP * \fBToElement\fP () const "
.br
.ti -1c
.RI "virtual const \fBXMLText\fP * \fBToText\fP () const "
.br
.ti -1c
.RI "virtual const \fBXMLComment\fP * \fBToComment\fP () const "
.br
.ti -1c
.RI "virtual const \fBXMLDocument\fP * \fBToDocument\fP () const "
.br
.ti -1c
.RI "virtual const \fBXMLDeclaration\fP * \fBToDeclaration\fP () const "
.br
.ti -1c
.RI "virtual const \fBXMLUnknown\fP * \fBToUnknown\fP () const "
.br
.ti -1c
.RI "const char * \fBValue\fP () const "
.br
.ti -1c
.RI "void \fBSetValue\fP (const char *val, bool staticMem=false)"
.br
.ti -1c
.RI "const \fBXMLNode\fP * \fBParent\fP () const "
.br
.RI "\fIGet the parent of this node on the DOM\&. \fP"
.ti -1c
.RI "\fBXMLNode\fP * \fBParent\fP ()"
.br
.ti -1c
.RI "bool \fBNoChildren\fP () const "
.br
.RI "\fIReturns true if this node has no children\&. \fP"
.ti -1c
.RI "const \fBXMLNode\fP * \fBFirstChild\fP () const "
.br
.RI "\fIGet the first child node, or null if none exists\&. \fP"
.ti -1c
.RI "\fBXMLNode\fP * \fBFirstChild\fP ()"
.br
.ti -1c
.RI "const \fBXMLElement\fP * \fBFirstChildElement\fP (const char *value=0) const "
.br
.ti -1c
.RI "\fBXMLElement\fP * \fBFirstChildElement\fP (const char *value=0)"
.br
.ti -1c
.RI "const \fBXMLNode\fP * \fBLastChild\fP () const "
.br
.RI "\fIGet the last child node, or null if none exists\&. \fP"
.ti -1c
.RI "\fBXMLNode\fP * \fBLastChild\fP ()"
.br
.ti -1c
.RI "const \fBXMLElement\fP * \fBLastChildElement\fP (const char *value=0) const "
.br
.ti -1c
.RI "\fBXMLElement\fP * \fBLastChildElement\fP (const char *value=0)"
.br
.ti -1c
.RI "const \fBXMLNode\fP * \fBPreviousSibling\fP () const "
.br
.RI "\fIGet the previous (left) sibling node of this node\&. \fP"
.ti -1c
.RI "\fBXMLNode\fP * \fBPreviousSibling\fP ()"
.br
.ti -1c
.RI "const \fBXMLElement\fP * \fBPreviousSiblingElement\fP (const char *value=0) const "
.br
.RI "\fIGet the previous (left) sibling element of this node, with an optionally supplied name\&. \fP"
.ti -1c
.RI "\fBXMLElement\fP * \fBPreviousSiblingElement\fP (const char *value=0)"
.br
.ti -1c
.RI "const \fBXMLNode\fP * \fBNextSibling\fP () const "
.br
.RI "\fIGet the next (right) sibling node of this node\&. \fP"
.ti -1c
.RI "\fBXMLNode\fP * \fBNextSibling\fP ()"
.br
.ti -1c
.RI "const \fBXMLElement\fP * \fBNextSiblingElement\fP (const char *value=0) const "
.br
.RI "\fIGet the next (right) sibling element of this node, with an optionally supplied name\&. \fP"
.ti -1c
.RI "\fBXMLElement\fP * \fBNextSiblingElement\fP (const char *value=0)"
.br
.ti -1c
.RI "\fBXMLNode\fP * \fBInsertEndChild\fP (\fBXMLNode\fP *addThis)"
.br
.ti -1c
.RI "\fBXMLNode\fP * \fBLinkEndChild\fP (\fBXMLNode\fP *addThis)"
.br
.ti -1c
.RI "\fBXMLNode\fP * \fBInsertFirstChild\fP (\fBXMLNode\fP *addThis)"
.br
.ti -1c
.RI "\fBXMLNode\fP * \fBInsertAfterChild\fP (\fBXMLNode\fP *afterThis, \fBXMLNode\fP *addThis)"
.br
.ti -1c
.RI "void \fBDeleteChildren\fP ()"
.br
.ti -1c
.RI "void \fBDeleteChild\fP (\fBXMLNode\fP *node)"
.br
.ti -1c
.RI "virtual \fBXMLNode\fP * \fBShallowClone\fP (\fBXMLDocument\fP *document) const =0"
.br
.ti -1c
.RI "virtual bool \fBShallowEqual\fP (const \fBXMLNode\fP *compare) const =0"
.br
.ti -1c
.RI "virtual bool \fBAccept\fP (\fBXMLVisitor\fP *visitor) const =0"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBXMLNode\fP (\fBXMLDocument\fP *)"
.br
.ti -1c
.RI "virtual char * \fBParseDeep\fP (char *, \fBStrPair\fP *)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBXMLDocument\fP * \fB_document\fP"
.br
.ti -1c
.RI "\fBXMLNode\fP * \fB_parent\fP"
.br
.ti -1c
.RI "\fBStrPair\fP \fB_value\fP"
.br
.ti -1c
.RI "\fBXMLNode\fP * \fB_firstChild\fP"
.br
.ti -1c
.RI "\fBXMLNode\fP * \fB_lastChild\fP"
.br
.ti -1c
.RI "\fBXMLNode\fP * \fB_prev\fP"
.br
.ti -1c
.RI "\fBXMLNode\fP * \fB_next\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBUnlink\fP (\fBXMLNode\fP *child)"
.br
.ti -1c
.RI "void \fBInsertChildPreamble\fP (\fBXMLNode\fP *insertThis) const "
.br
.ti -1c
.RI "\fBXMLNode\fP (const \fBXMLNode\fP &)"
.br
.ti -1c
.RI "\fBXMLNode\fP & \fBoperator=\fP (const \fBXMLNode\fP &)"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static void \fBDeleteNode\fP (\fBXMLNode\fP *node)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBMemPool\fP * \fB_memPool\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBXMLDocument\fP"
.br
.ti -1c
.RI "class \fBXMLElement\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBXMLNode\fP is a base class for every object that is in the XML Document Object Model (DOM), except XMLAttributes\&. Nodes have siblings, a parent, and children which can be navigated\&. A node is always in a \fBXMLDocument\fP\&. The type of a \fBXMLNode\fP can be queried, and it can be cast to its more defined type\&.
.PP
A \fBXMLDocument\fP allocates memory for all its Nodes\&. When the \fBXMLDocument\fP gets deleted, all its Nodes will also be deleted\&.
.PP
.PP
.nf
A Document can contain: Element (container or leaf)
                        Comment (leaf)
                        Unknown (leaf)
                        Declaration( leaf )

An Element can contain: Element (container or leaf)
                        Text    (leaf)
                        Attributes (not on tree)
                        Comment (leaf)
                        Unknown (leaf).fi
.PP
 
.SH "Member Function Documentation"
.PP 
.SS "virtual bool tinyxml2::XMLNode::Accept (\fBXMLVisitor\fP * visitor) const\fC [pure virtual]\fP"
Accept a hierarchical visit of the nodes in the TinyXML-2 DOM\&. Every node in the XML tree will be conditionally visited and the host will be called back via the \fBXMLVisitor\fP interface\&.
.PP
This is essentially a SAX interface for TinyXML-2\&. (Note however it doesn't re-parse the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this interface versus any other\&.)
.PP
The interface has been based on ideas from:
.PP
.IP "\(bu" 2
http://www.saxproject.org/
.IP "\(bu" 2
http://c2.com/cgi/wiki?HierarchicalVisitorPattern
.PP
.PP
Which are both good references for 'visiting'\&.
.PP
An example of using \fBAccept()\fP: 
.PP
.nf
XMLPrinter printer;
tinyxmlDoc.Accept( &printer );
const char* xmlcstr = printer.CStr();

.fi
.PP
 
.PP
Implemented in \fBtinyxml2::XMLDocument\fP, \fBtinyxml2::XMLElement\fP, \fBtinyxml2::XMLUnknown\fP, \fBtinyxml2::XMLDeclaration\fP, \fBtinyxml2::XMLComment\fP, and \fBtinyxml2::XMLText\fP\&.
.SS "void tinyxml2::XMLNode::DeleteChild (\fBXMLNode\fP * node)"
Delete a child of this node\&. 
.SS "void tinyxml2::XMLNode::DeleteChildren ()"
Delete all the children of this node\&. 
.SS "const \fBXMLElement\fP* tinyxml2::XMLNode::FirstChildElement (const char * value = \fC0\fP) const"
Get the first child element, or optionally the first child element with the specified name\&. 
.SS "\fBXMLNode\fP* tinyxml2::XMLNode::InsertAfterChild (\fBXMLNode\fP * afterThis, \fBXMLNode\fP * addThis)"
Add a node after the specified child node\&. If the child node is already part of the document, it is moved from its old location to the new location\&. Returns the addThis argument or 0 if the afterThis node is not a child of this node, or if the node does not belong to the same document\&. 
.SS "\fBXMLNode\fP* tinyxml2::XMLNode::InsertEndChild (\fBXMLNode\fP * addThis)"
Add a child node as the last (right) child\&. If the child node is already part of the document, it is moved from its old location to the new location\&. Returns the addThis argument or 0 if the node does not belong to the same document\&. 
.SS "\fBXMLNode\fP* tinyxml2::XMLNode::InsertFirstChild (\fBXMLNode\fP * addThis)"
Add a child node as the first (left) child\&. If the child node is already part of the document, it is moved from its old location to the new location\&. Returns the addThis argument or 0 if the node does not belong to the same document\&. 
.SS "const \fBXMLElement\fP* tinyxml2::XMLNode::LastChildElement (const char * value = \fC0\fP) const"
Get the last child element or optionally the last child element with the specified name\&. 
.SS "void tinyxml2::XMLNode::SetValue (const char * val, bool staticMem = \fCfalse\fP)"
Set the Value of an XML node\&. 
.PP
\fBSee also:\fP
.RS 4
\fBValue()\fP 
.RE
.PP

.SS "virtual \fBXMLNode\fP* tinyxml2::XMLNode::ShallowClone (\fBXMLDocument\fP * document) const\fC [pure virtual]\fP"
Make a copy of this node, but not its children\&. You may pass in a Document pointer that will be the owner of the new Node\&. If the 'document' is null, then the node returned will be allocated from the current Document\&. (this->\fBGetDocument()\fP)
.PP
Note: if called on a \fBXMLDocument\fP, this will return null\&. 
.PP
Implemented in \fBtinyxml2::XMLDocument\fP, \fBtinyxml2::XMLElement\fP, \fBtinyxml2::XMLUnknown\fP, \fBtinyxml2::XMLDeclaration\fP, \fBtinyxml2::XMLComment\fP, and \fBtinyxml2::XMLText\fP\&.
.SS "virtual bool tinyxml2::XMLNode::ShallowEqual (const \fBXMLNode\fP * compare) const\fC [pure virtual]\fP"
Test if 2 nodes are the same, but don't test children\&. The 2 nodes do not need to be in the same Document\&.
.PP
Note: if called on a \fBXMLDocument\fP, this will return false\&. 
.PP
Implemented in \fBtinyxml2::XMLDocument\fP, \fBtinyxml2::XMLElement\fP, \fBtinyxml2::XMLUnknown\fP, \fBtinyxml2::XMLDeclaration\fP, \fBtinyxml2::XMLComment\fP, and \fBtinyxml2::XMLText\fP\&.
.SS "const char* tinyxml2::XMLNode::Value () const"
The meaning of 'value' changes for the specific type\&. 
.PP
.nf
Document:   empty (NULL is returned, not an empty string)
Element:    name of the element
Comment:    the comment text
Unknown:    the tag contents
Text:       the text string

.fi
.PP
 

.SH "Author"
.PP 
Generated automatically by Doxygen for cpp_bomberman from the source code\&.
